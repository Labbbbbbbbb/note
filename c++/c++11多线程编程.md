# C++多线程

## 一、创建线程

### 使用```std::thread```创建其他线程

需包含头文件```<thread>```

```std::thread```

![image-20230131213338204](c++11多线程编程.assets/image-20230131213338204.png)

新县城将在创建新对象后立即开始，并行执行回调。可以使用```std::thread```来附加一个回调，当新线程启动时，回调将被执行。此外，任何线程可以通过在该线程的对象上调用join()函数来等待另一个线程退出。

多线程运行是以异步形式进行，可以同时执行多条语句。

回调：

1. 函数指针
2.  函数对象
3. Lambda函数

```cpp
std::thread thOBJ(<CALLBACK>)
```

#### 函数指针

```cpp
#include <iostream>
#include <thread>
 
void thread_function() {
  for (int i = 0; i < 100; i++)
    std::cout << "thread function excuting" << std::endl;
}
 
int main() {
  std::thread threadObj(thread_function);
  for (int i = 0; i < 100; i++)
    std::cout << "Display from MainThread" << std::endl;
  threadObj.join();
  std::cout << "Exit of Main function" << std::endl;
  return 0;
}

/*
输出结果中会出现两句虎牙不同时刻出现
*/
```

函数对象创建线程：

```cpp
#include <iostream>
#include <thread>
 
class DisplayThread {
 public:
  void operator ()() {
    for (int i = 0; i < 100; i++)
      std::cout << "Display Thread Excecuting" << std::endl;
  }
};
 
int main() {
  std::thread threadObj((DisplayThread()));
  for (int i = 0; i < 100; i++)
    std::cout << "Display From Main Thread " << std::endl;
  std::cout << "Waiting For Thread to complete" << std::endl;
  threadObj.join();
  std::cout << "Exiting from Main Thread" << std::endl;
 
  return 0;
}
```



## 二、joining和detaching 线程

### ```Joining```线程

线程一旦启动，另一个线程可以通过调用std::thread对象上调用join()函数等待这个线程执行完毕。

```cpp
std::thread th(funcPtr); 
th.join();
```

### ```Detaching```线程

detach一个线程，需要在std::thread对象中调用std::detach()函数。调用detach()后，std::thread对象不再与实际执行线程相关联，在线程句柄上调用detach() 和 join()要小心 。

```cpp
std::thread th(funcPtr)
th.detach();
```

当join()函数在线程对象上执行,当join()返回时，std::thread 对象与他没有关联线程，如果在这样的对象上再次调用join()函数，那么它将导致程序终止。类似的，调用detach()使std::thread对象没有链接任何线程函数，在这种情况下，在一个std::thread对象上调用detach()函数两次将导致程序终止。

因此，在每次调用join()或detach()前，需要检查线程是否join-able

```cpp
std::thread threadObj(WorkerThread())
if(threadObj.joinable()){
	std::cout<<"Detaching Thread"<<std::endl;
	threadObj.detach();
}
if(threadObj.joinable()){
	std::cout<<"Detaching Thread"<<std::endl;
	threadObj.detach();
}
 
std::thread threadObj2(WorkerThread())
if(threadObj2.joinable()){
	std::cout<<"Joining Thread"<<std::endl;
	threadObj2.join();
}
if(threadObj2.joinable()){
	std::cout<<"Joining Thread"<<std::endl;
	threadObj2.join();
}
```

**case2:不要忘记使用关联的执行线程在std::thread对象上调用join或detach**

如果std::thread关联的执行线程没有调用join和detach，那么在对象的析构期，它将终止程序

因为在析构期，它将检查线程是否仍然Join-able，然后终止程序。

```cpp
#include <iostream>
#include <thread>
#include <algorithm>
 
 
class WorkerThread
{
public:
    void operator()()
    {
        std::cout << "Worker Thread" << std::endl;
    }
};
 
 
int main()
{
    std::thread threadObj((WorkerThread()));
    //如果没有在std::thread对象上调用join或detach，其析构函数将会终止程序
    return 0;
}
```

## 三、将参数传递给线程

要将参数传递给线程的可关联对象或函数，只需将参数传递给std::thread构造函数。

```cpp
#include <iostream>
#include <string>
#include <thread>
 
void threadCallback(int x, std::string str) {
  std::cout << "Passed Number = " << x << std::endl;
  std::cout << "Passed String = " << str << std::endl;
}
int main() {
  int x = 10;
  std::string str = "Sample String";
  std::thread threadObj(threadCallback, x, str);
  threadObj.join();
  return 0;
}
```

**给线程传递函数** 
 不要将本地堆栈变量的地址传递给线程的回调函数，因为线程1中的局部变量可能会超出范围，但线程2仍然尝试通过它的地址访问它。 在这种情况下，访问无效地址可能会导致不可预测的行为.

同样的，在将指针传递给位于heap上的线程时，要小心，因为某些线程可能在新线程尝试访问它之前删除该内存。 在这种情况下，访问无效地址可能会导致不可预测的行为。

```cpp
#include <iostream>
#include <thread>
 
void newThreadCallback(int* p)  {
  std::cout << "Inside Thread :  "" : p = " << *p << std::endl;
  std::chrono::milliseconds dura(1000);
  std::this_thread::sleep_for(dura);
  *p = 19;
}
 
void startNewThread()  {
  int i = 10;
  std::cout << "Inside Main Thread :  "" : i = " << i << std::endl;
  std::thread t(newThreadCallback, &i);
  t.detach();
  std::cout << "Inside Main Thread :  "" : i = " << i << std::endl;
}
 
int main()  {
  startNewThread();
  std::chrono::milliseconds dura(2000);
  std::this_thread::sleep_for(dura);
  return 0;
}  
```

